import React, { Fragment, useCallback, useContext, useMemo, useRef } from 'react';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import noop from '@atlaskit/ds-lib/noop';
import useAutoFocus from '@atlaskit/ds-lib/use-auto-focus';
// eslint-disable-next-line no-duplicate-imports
import InteractionContext from '@atlaskit/interaction-context';
import { Box, xcss } from '@atlaskit/primitives';
import { useSplitButtonContext } from '../../containers/split-button/split-button-context';
import blockEvents from './block-events';
import { getXCSS } from './xcss';

// Include modified onClick with analytics

const overlayStyles = xcss({
  position: 'absolute',
  insetInlineStart: 'space.0',
  insetBlockStart: 'space.0',
  insetInlineEnd: 'space.0',
  insetBlockEnd: 'space.0',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center'
});

/**
 * __Use button base__
 *
 * A React hook that accepts a set of common Button props,
 * and processes them to return consistent base props for usage
 * across various Button components.
 *
 * It also:
 * - Implements auto focus when enabled.
 * - Appends the `onClick` event with UFO analytics tracking.
 *
 * @private
 */
const useButtonBase = ({
  analyticsContext,
  appearance: propAppearance = 'default',
  autoFocus = false,
  buttonType,
  interactionName,
  isDisabled: propIsDisabled = false,
  isSelected = false,
  // TODO: Separate Icon Button styling from button base
  isIconButton = false,
  isCircle = false,
  // TODO: Separate icon slot styling from button base
  hasIconBefore = false,
  hasIconAfter = false,
  children,
  onClick: providedOnClick = noop,
  onMouseDownCapture,
  onMouseUpCapture,
  onKeyDownCapture,
  onKeyUpCapture,
  onTouchStartCapture,
  onTouchEndCapture,
  onPointerDownCapture,
  onPointerUpCapture,
  onClickCapture,
  overlay,
  ref,
  shouldFitContainer = false,
  spacing: propSpacing = 'default'
}) => {
  const ourRef = useRef();
  const splitButtonContext = useSplitButtonContext();
  const isSplitButton = Boolean(splitButtonContext);
  const isNavigationSplitButton = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.isNavigationSplitButton) || false;
  const appearance = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.appearance) || propAppearance;
  const spacing = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.spacing) || propSpacing;
  const isDisabled = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.isDisabled) || propIsDisabled;
  const isHighlighted = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.isHighlighted) || false;
  const isActiveOverSelected = (splitButtonContext === null || splitButtonContext === void 0 ? void 0 : splitButtonContext.isActiveOverSelected) || false;
  const setRef = useCallback(node => {
    ourRef.current = node;
    if (ref === null) {
      return;
    }
    if (typeof ref === 'function') {
      ref(node);
      return;
    }

    // @ts-ignore
    ref.current = node;
  }, [ourRef, ref]);
  useAutoFocus(ourRef, autoFocus);
  const interactionContext = useContext(InteractionContext);
  const handleClick = useCallback((e, analyticsEvent) => {
    interactionContext && interactionContext.tracePress(interactionName, e.timeStamp);
    providedOnClick(e, analyticsEvent);
  }, [providedOnClick, interactionContext, interactionName]);
  const onClick = usePlatformLeafEventHandler({
    fn: handleClick,
    action: 'clicked',
    componentName: 'button',
    packageName: "@atlaskit/button",
    packageVersion: "17.3.2",
    analyticsData: analyticsContext,
    actionSubject: buttonType
  });
  const buttonXCSS = useMemo(() => getXCSS({
    appearance,
    spacing,
    isDisabled,
    isSelected,
    isHighlighted,
    isActiveOverSelected,
    shouldFitContainer,
    isIconButton,
    isCircle,
    hasOverlay: Boolean(overlay),
    isLink: buttonType === 'link',
    hasIconBefore,
    hasIconAfter,
    isSplit: isSplitButton,
    isNavigationSplit: isNavigationSplitButton
  }), [appearance, buttonType, spacing, isDisabled, isSelected, isHighlighted, isActiveOverSelected, isIconButton, isCircle, shouldFitContainer, overlay, hasIconBefore, hasIconAfter, isSplitButton, isNavigationSplitButton]);
  const isEffectivelyDisabled = isDisabled || Boolean(overlay);
  return {
    ref: setRef,
    xcss: buttonXCSS,
    // Consider overlay buttons to be effectively disabled
    isDisabled: isEffectivelyDisabled,
    children: /*#__PURE__*/React.createElement(Fragment, null, children, overlay ? /*#__PURE__*/React.createElement(Box, {
      as: "span",
      xcss: overlayStyles
    }, overlay) : null),
    ...blockEvents(isEffectivelyDisabled, {
      onClick,
      onMouseDownCapture,
      onMouseUpCapture,
      onKeyDownCapture,
      onKeyUpCapture,
      onTouchStartCapture,
      onTouchEndCapture,
      onPointerDownCapture,
      onPointerUpCapture,
      onClickCapture
    })
  };
};
export default useButtonBase;